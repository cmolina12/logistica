import pandas as pdimport networkx as nximport matplotlib.pyplot as plt# Importar datosdf_r = pd.read_excel("Plantilla - Laboratorio 2.xlsx", sheet_name = "Punto1_Rutas")df_c = pd.read_excel("Plantilla - Laboratorio 2.xlsx", sheet_name = "Punto1_Ciudades")print(df_r.head())print(df_c.head())# 1.1. Diseñar  un  grafo  dirigido  que  represente  la  red  completa  de  todas  rutas  disponibles,  donde  las  ciudades  serán  los  nodos  y  las  rutas  los  arcos.  Asegúrese  de  que  en  cada  arco  se  calcule  y  muestre explícitamente  el  costo  logístico  total  del  trayecto.  Insertar  la  imagen  del  grafo  generado  en  el  inciso correspondiente. def grafo_completo(df_r):        G = nx.DiGraph()        for _, row in df_r.iterrows():                origen = row["Origen"]        destino = row["Destino"]        distancia = row["Distancia_km"]        tipo_transporte = row["Transporte"]                constante = (1 if tipo_transporte =="Camion" else 1.5 if tipo_transporte=="Barco" else 2)                costo = 10 * distancia + 100 * constante                G.add_edge(origen, destino, costo=costo)            return GG = grafo_completo(df_r)plt.figure(figsize=(12, 8), facecolor="white")pos = nx.spring_layout(G)nx.draw_networkx(    G,    pos,    with_labels=True,    node_color="lightblue",    edge_color="gray",    node_size=700,    font_size=10,)# Mostrar los costos en las aristasedge_labels = nx.get_edge_attributes(G, "costo")nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color="green")plt.title("Grafo Dirigido de Rutas de Transporte")plt.axis("off")plt.show()# 1.2 El Centro de Distribución de Bogotá debe enviar urgentemente cinco cajas de vacunas al Hospital Regional de Quito, debido a un brote epidémico en dicha ciudad. Por requerimientos sanitarios, el envío debe pasar obligatoriamente por la estación de Medellín para validación de cadena de frío y documentación.# cinco cajas de 20 kg cada unacarga = 20 * 5autonomia = {}for _, row in df_c.iterrows():    ciudad = row["Nombre"]    autonomia[ciudad] = row["Autonomia"]def grafo_reducido(df_r):        G = nx.DiGraph()        for _, row in df_r.iterrows():                origen = row['Origen']        destino = row['Destino']        tipo_transporte = row['Transporte']        clima = row['Clima']        ventana_horaria = row['Ventana_Horaria']        capacidad = float(row['Capacidad_Maxima_kg'])        distancia = float(row['Distancia_km'])        refrigeracion = row['Refrigeracion']        tiempo_estimado_horas = float(row['Tiempo_estimado_h'])                # Filtro 1 - No se puede clima "Tormenta"                if clima == "Tormenta":            continue                # Filtro 2 - Ventana horaria debe ser mayor o igual a 8 horas                inicio, fin = map(int, ventana_horaria.split("-"))                if fin - inicio < 8:            continue                # Filtro 3 - Refrigreacion debe estar disponible                if refrigeracion == "No":            continue                # Penalizacion                if carga > capacidad:            penalizacion = 0.15        else:            penalizacion = 0                    constante = (1 if tipo_transporte =="Camion" else 1.5 if tipo_transporte=="Barco" else 2)                costo = (10 * distancia + 100 * constante) * (1+penalizacion)                G.add_edge(origen,                    destino,                    costo=costo,                   distancia=distancia,                   tiempo=tiempo_estimado_horas,                   transporte=tipo_transporte,                   clima=clima,                   ventana=ventana_horaria,                   capacidad=capacidad,                   refrigeracion=refrigeracion)                    for node in G.nodes():        G.nodes[node]["autonomia"] = autonomia.get(node, "Media")        return G        grafo = grafo_reducido(df_r)# Dijkstraimport heapqdef dijkstra (G, source, target, ciudad_obligatoria):        def es_baja(nodo):                return G.nodes[nodo]["autonomia"] == "Baja"            medallo = 1 if source == ciudad_obligatoria else 0        baja = 1 if es_baja(source) else 0         heap = [(0,0,source,medallo,baja,[source])]        visitados = dict()        while heap:                costo_acumulado, tiempo_acumulado, nodo, medallo, baja, ruta = heapq.heappop(heap)                                # Principio de optimalidad                clave = (nodo, medallo, baja)                if clave in visitados and visitados[clave] <= (costo_acumulado, tiempo_acumulado):            continue                visitados[clave] = (costo_acumulado, tiempo_acumulado)                        # Principio de llegada                if nodo == target and medallo == 1 and baja <= 1:                        distancia = sum(G[ruta[i]][ruta[i+1]]['distancia'] for i in range(len(ruta)-1))                        return ruta, costo_acumulado, tiempo_acumulado, distancia                for vecino in G.neighbors(nodo):                        if vecino in ruta:                continue                        arista = G.get_edge_data(nodo, vecino)                        costo_acumulado_nuevo = costo_acumulado + arista["costo"]            tiempo_acumulado_nuevo = tiempo_acumulado + arista["tiempo"]            nodo_nuevo = vecino            medallo_nuevo = 1 if (medallo or (vecino==ciudad_obligatoria)) else 0            baja_nuevo = baja + (1 if es_baja(vecino) else 0)                        if baja_nuevo > 1:                continue                        heapq.heappush(heap, (costo_acumulado_nuevo, tiempo_acumulado_nuevo, nodo_nuevo, medallo_nuevo, baja_nuevo, ruta + [vecino]))                        return None, float("inf"), float("inf"), float("inf")    ruta, costo, tiempo, distancia = dijkstra(grafo, "Bogotá", "Quito", "Medellín")print(ruta)print(costo)print(tiempo)print(distancia)        